## 一面：

### 1.springboot的启动与加载流程 (==没回答上来==)

答：
Spring Boot 是一个用于构建独立的、生产级别的 Spring 应用程序的框架。下面是 Spring Boot 应用程序的启动与加载流程的简要概述：

1. **启动类：** Spring Boot 应用程序的启动类通常包含了 `main` 方法，它是应用程序的入口点。在这个类上使用 `@SpringBootApplication` 注解来标识它是一个 Spring Boot 应用程序的启动类。

2. **Spring Boot 上下文加载：** 当启动类的 `main` 方法被执行时，Spring Boot 应用程序的上下文开始加载。这个过程包括创建 Spring 应用程序上下文，并进行初始化，包括组件扫描、依赖注入、配置加载等。

3. **自动配置：** Spring Boot 使用自动配置来尽量减少开发者的配置工作。在上下文加载期间，Spring Boot 会自动根据项目的依赖和配置，尝试自动配置各种功能和组件，例如数据库连接池、Web服务器、消息队列等。

4. **属性加载：** Spring Boot 使用属性文件（`application.properties` 或 `application.yml`）来配置应用程序的各种属性。这些属性可以通过 Spring 的 `Environment` 对象获取，用于配置各种组件和功能。

5. **组件扫描与 Bean 注册：** Spring Boot 默认使用组件扫描来查找和注册 Spring Bean。你可以使用 `@Component`、`@Service`、`@Repository`、`@Controller` 等注解来标识各种组件类，并使它们成为 Spring 管理的 Bean。

6. **条件化配置：** Spring Boot 支持条件化配置，根据不同的条件选择性地配置应用程序的组件。可以使用条件注解（如 `@ConditionalOnProperty`、`@ConditionalOnClass` 等）来实现这些条件。

7. **ApplicationRunner 和 CommandLineRunner：** 如果你需要在 Spring Boot 应用程序启动后执行一些特定的代码，可以实现 `ApplicationRunner` 或 `CommandLineRunner` 接口，并在其 `run` 方法中添加需要执行的逻辑。

8. **Web应用加载（如果适用）：** 如果你的 Spring Boot 应用程序是一个 Web 应用程序，那么在上下文加载后，Spring Boot 会初始化 Web 相关的组件，如 DispatcherServlet、ViewResolver 等，以支持 Web 请求的处理。

9. **启动 Web 服务器：** 如果是一个 Web 应用程序，Spring Boot 会自动启动嵌入式的 Web 服务器，例如 Tomcat、Jetty 或 Undertow，以便处理传入的 HTTP 请求。

10. **应用程序运行：** 一旦 Spring Boot 应用程序加载完成，Web 服务器就会准备好接受和处理来自客户端的请求，同时也会执行前面提到的 `ApplicationRunner` 或 `CommandLineRunner` 中的代码。

这只是 Spring Boot 启动与加载流程的一个简要概述，实际上还涉及更多细节和复杂性。如果你想深入了解 Spring Boot 的启动流程，建议查阅 Spring Boot 官方文档以及相关的教程和资料。

### 2.消息队列中怎么确定消息已经被消费了？
答：
在消息队列系统中，确定消息是否已经被消费通常需要考虑一些策略和机制。下面是一些常见的方法：

1. **确认机制（Acknowledge Mechanism）：** 大多数消息队列系统提供了确认机制，其中消费者在处理完消息后发送确认信号给消息队列。这通常被称为消息确认（Message Acknowledgment）、应答（Acknowledgment）或者完成确认（Completion Acknowledgment）。一旦消息队列接收到确认，它就会将消息标记为已处理，然后从队列中移除。

2. **轮询和拉取：** 消费者可以定期轮询或者拉取消息队列以获取新消息。当消费者拉取消息后，消息队列可以立即将消息标记为已消费。如果消费者没有确认处理消息，消息队列可能会将消息重新放回队列中，以确保消息不会丢失。

3. **消费者状态跟踪：** 消费者可以在处理消息后在自己的状态中记录消息的处理情况。这可以是一个数据库、缓存或者其他持久化存储。通过维护消费者的状态信息，可以跟踪消息的消费状态。

4. **消息锁定：** 某些情况下，消费者可以在开始处理消息时锁定消息。这意味着在消息处理完成之前，其他消费者无法处理相同的消息。如果消费者成功处理消息，则会确认并释放消息锁定。如果处理失败，则消息可以重新处理或由其他消费者处理。

5. **超时处理：** 如果消费者在一定时间内没有确认处理消息，消息队列系统可以将消息标记为超时，并可能重新将其放回队列中以供重新处理。

6. **死信队列：** 如果消息消费失败达到一定次数，消息队列系统可以将消息移动到一个特殊的死信队列中。这样可以对处理失败的消息进行后续的分析和处理。

7. **事件日志：** 将消息消费的情况记录在事件日志中，以便后续进行审计和故障排除。

要根据具体的消息队列系统和应用需求来选择适合的确认和监控机制。在某些情况下，可能需要使用多种方法的组合来确保消息的可靠处理。

### 3.确认机制中应答需要自己写吗？
答：

是的，在大多数消息队列系统中，消费者需要自己实现确认（应答）机制。这意味着在消费者处理完消息之后，需要显式地发送确认信号给消息队列，以告知消息队列该消息已经被成功处理，可以从队列中移除。

具体来说，消息队列系统通常会提供一些API或方法，供消费者调用来发送确认信号。这通常被称为“确认”（Acknowledge）、“应答”（Acknowledgment）或“完成确认”（Completion Acknowledgment）等。这些方法的使用方式可能因消息队列系统而异。

例如，在使用RabbitMQ消息队列的情况下，你可以通过调用`basicAck`方法来发送确认信号，告知消息队列某个特定的消息已经被处理。在Kafka中，你可以通过提交消费者位移（Consumer Offset）来表示消息已经被成功消费。

确保正确地实现确认机制对于保证消息的可靠传递和消费是非常重要的，因为消息队列系统依赖于这些确认信号来管理消息的状态和处理。如果消费者在处理完消息后没有发送确认信号，消息队列可能会将消息重新分配给其他消费者，从而可能导致消息被多次处理或消息丢失等问题。

### 4.注册中心Nacos热部署怎么实现的?
答：
截止到我知识截止日（2021年9月），Nacos（阿里巴巴开源的服务发现和配置管理工具）并没有提供官方支持的热部署机制。然而，你可以通过一些方法来实现近似的热部署效果，具体取决于你的使用场景和需求。

以下是一些可能的方法来实现 Nacos 的近似热部署：

1. **动态刷新配置：** Nacos允许你在运行时动态更新配置信息。你可以在应用程序中监听配置变更事件，并在配置发生更改时重新加载相关的配置数据，从而实现一种近似的热部署效果。

2. **定时任务检测变更：** 可以设置一个定时任务，定期从 Nacos 获取最新的配置信息，并在发现配置发生更改时触发相应的更新操作。这种方法可以在一定程度上模拟热部署，但需要你自己实现定时任务逻辑。

3. **结合自动化部署工具：** 如果你使用自动化部署工具（如Kubernetes、Docker等），你可以通过升级容器、镜像等方式来实现类似的效果。在这种情况下，你可以更新应用的部署描述文件，然后使用自动化工具进行滚动更新，以实现应用的热部署。

需要注意的是，Nacos的发展可能会在我知识截止日之后有所变化，因此我建议你查阅 Nacos 的最新文档和社区资料，以了解是否有新的官方支持或者社区推荐的热部署方法。

### 5.多线程的一些问题，回答上来了。

### 6.Feign的问题(==没用过，所以没回答上来==)

### 7.询问了下前端技能和GoLang

### 8.简单说了一下做过的项目