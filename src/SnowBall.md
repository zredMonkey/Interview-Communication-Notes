## 一面：

### 1.springboot的启动与加载流程 (==没回答上来==)

答：
Spring Boot 是一个用于构建独立的、生产级别的 Spring 应用程序的框架。下面是 Spring Boot 应用程序的启动与加载流程的简要概述：

1. **启动类：** Spring Boot 应用程序的启动类通常包含了 `main` 方法，它是应用程序的入口点。在这个类上使用 `@SpringBootApplication` 注解来标识它是一个 Spring Boot 应用程序的启动类。

2. **Spring Boot 上下文加载：** 当启动类的 `main` 方法被执行时，Spring Boot 应用程序的上下文开始加载。这个过程包括创建 Spring 应用程序上下文，并进行初始化，包括组件扫描、依赖注入、配置加载等。

3. **自动配置：** Spring Boot 使用自动配置来尽量减少开发者的配置工作。在上下文加载期间，Spring Boot 会自动根据项目的依赖和配置，尝试自动配置各种功能和组件，例如数据库连接池、Web服务器、消息队列等。

4. **属性加载：** Spring Boot 使用属性文件（`application.properties` 或 `application.yml`）来配置应用程序的各种属性。这些属性可以通过 Spring 的 `Environment` 对象获取，用于配置各种组件和功能。

5. **组件扫描与 Bean 注册：** Spring Boot 默认使用组件扫描来查找和注册 Spring Bean。你可以使用 `@Component`、`@Service`、`@Repository`、`@Controller` 等注解来标识各种组件类，并使它们成为 Spring 管理的 Bean。

6. **条件化配置：** Spring Boot 支持条件化配置，根据不同的条件选择性地配置应用程序的组件。可以使用条件注解（如 `@ConditionalOnProperty`、`@ConditionalOnClass` 等）来实现这些条件。

7. **ApplicationRunner 和 CommandLineRunner：** 如果你需要在 Spring Boot 应用程序启动后执行一些特定的代码，可以实现 `ApplicationRunner` 或 `CommandLineRunner` 接口，并在其 `run` 方法中添加需要执行的逻辑。

8. **Web应用加载（如果适用）：** 如果你的 Spring Boot 应用程序是一个 Web 应用程序，那么在上下文加载后，Spring Boot 会初始化 Web 相关的组件，如 DispatcherServlet、ViewResolver 等，以支持 Web 请求的处理。

9. **启动 Web 服务器：** 如果是一个 Web 应用程序，Spring Boot 会自动启动嵌入式的 Web 服务器，例如 Tomcat、Jetty 或 Undertow，以便处理传入的 HTTP 请求。

10. **应用程序运行：** 一旦 Spring Boot 应用程序加载完成，Web 服务器就会准备好接受和处理来自客户端的请求，同时也会执行前面提到的 `ApplicationRunner` 或 `CommandLineRunner` 中的代码。

这只是 Spring Boot 启动与加载流程的一个简要概述，实际上还涉及更多细节和复杂性。如果你想深入了解 Spring Boot 的启动流程，建议查阅 Spring Boot 官方文档以及相关的教程和资料。

### 2.消息队列中怎么确定消息已经被消费了？
答：
在消息队列系统中，确定消息是否已经被消费通常需要考虑一些策略和机制。下面是一些常见的方法：

1. **确认机制（Acknowledge Mechanism）：** 大多数消息队列系统提供了确认机制，其中消费者在处理完消息后发送确认信号给消息队列。这通常被称为消息确认（Message Acknowledgment）、应答（Acknowledgment）或者完成确认（Completion Acknowledgment）。一旦消息队列接收到确认，它就会将消息标记为已处理，然后从队列中移除。

2. **轮询和拉取：** 消费者可以定期轮询或者拉取消息队列以获取新消息。当消费者拉取消息后，消息队列可以立即将消息标记为已消费。如果消费者没有确认处理消息，消息队列可能会将消息重新放回队列中，以确保消息不会丢失。

3. **消费者状态跟踪：** 消费者可以在处理消息后在自己的状态中记录消息的处理情况。这可以是一个数据库、缓存或者其他持久化存储。通过维护消费者的状态信息，可以跟踪消息的消费状态。

4. **消息锁定：** 某些情况下，消费者可以在开始处理消息时锁定消息。这意味着在消息处理完成之前，其他消费者无法处理相同的消息。如果消费者成功处理消息，则会确认并释放消息锁定。如果处理失败，则消息可以重新处理或由其他消费者处理。

5. **超时处理：** 如果消费者在一定时间内没有确认处理消息，消息队列系统可以将消息标记为超时，并可能重新将其放回队列中以供重新处理。

6. **死信队列：** 如果消息消费失败达到一定次数，消息队列系统可以将消息移动到一个特殊的死信队列中。这样可以对处理失败的消息进行后续的分析和处理。

7. **事件日志：** 将消息消费的情况记录在事件日志中，以便后续进行审计和故障排除。

要根据具体的消息队列系统和应用需求来选择适合的确认和监控机制。在某些情况下，可能需要使用多种方法的组合来确保消息的可靠处理。

### 3.确认机制中应答需要自己写吗？
答：

是的，在大多数消息队列系统中，消费者需要自己实现确认（应答）机制。这意味着在消费者处理完消息之后，需要显式地发送确认信号给消息队列，以告知消息队列该消息已经被成功处理，可以从队列中移除。

具体来说，消息队列系统通常会提供一些API或方法，供消费者调用来发送确认信号。这通常被称为“确认”（Acknowledge）、“应答”（Acknowledgment）或“完成确认”（Completion Acknowledgment）等。这些方法的使用方式可能因消息队列系统而异。

例如，在使用RabbitMQ消息队列的情况下，你可以通过调用`basicAck`方法来发送确认信号，告知消息队列某个特定的消息已经被处理。在Kafka中，你可以通过提交消费者位移（Consumer Offset）来表示消息已经被成功消费。

确保正确地实现确认机制对于保证消息的可靠传递和消费是非常重要的，因为消息队列系统依赖于这些确认信号来管理消息的状态和处理。如果消费者在处理完消息后没有发送确认信号，消息队列可能会将消息重新分配给其他消费者，从而可能导致消息被多次处理或消息丢失等问题。

### 4.注册中心Nacos热部署怎么实现的?
答：
截止到我知识截止日（2021年9月），Nacos（阿里巴巴开源的服务发现和配置管理工具）并没有提供官方支持的热部署机制。然而，你可以通过一些方法来实现近似的热部署效果，具体取决于你的使用场景和需求。

以下是一些可能的方法来实现 Nacos 的近似热部署：

1. **动态刷新配置：** Nacos允许你在运行时动态更新配置信息。你可以在应用程序中监听配置变更事件，并在配置发生更改时重新加载相关的配置数据，从而实现一种近似的热部署效果。

2. **定时任务检测变更：** 可以设置一个定时任务，定期从 Nacos 获取最新的配置信息，并在发现配置发生更改时触发相应的更新操作。这种方法可以在一定程度上模拟热部署，但需要你自己实现定时任务逻辑。

3. **结合自动化部署工具：** 如果你使用自动化部署工具（如Kubernetes、Docker等），你可以通过升级容器、镜像等方式来实现类似的效果。在这种情况下，你可以更新应用的部署描述文件，然后使用自动化工具进行滚动更新，以实现应用的热部署。

需要注意的是，Nacos的发展可能会在我知识截止日之后有所变化，因此我建议你查阅 Nacos 的最新文档和社区资料，以了解是否有新的官方支持或者社区推荐的热部署方法。

### 5.多线程的一些问题，回答上来了。

### 6.Feign的问题(==没用过，所以没回答上来==)

### 7.询问了下前端技能和GoLang

### 8.简单说了一下做过的项目

### 9.Redis的哨兵模式和集群是否有了解
答：
Redis的哨兵机制（Sentinel）是用于监控和管理Redis集群的一种机制，它提供了高可用性和自动故障转移的功能。哨兵系统可以在主节点（Master）发生故障时，自动将一个从节点（Slave）提升为新的主节点，从而实现故障恢复和集群的持续可用性。

以下是Redis哨兵机制的基本工作原理：

1. **哨兵角色：** 在一个Redis集群中，你可以配置一个或多个哨兵节点，它们的任务是监控Redis主节点和从节点的状态。哨兵节点之间相互通信，共同协调集群的管理。

2. **主节点监控：** 哨兵节点会定期检查主节点的状态，包括网络连接、响应能力等。如果主节点无法正常响应，哨兵会将该主节点标记为不可用。

3. **自动故障转移：** 当主节点被标记为不可用时，哨兵会选择一个从节点作为新的主节点，并协调集群中的其他哨兵节点进行投票，以确保选举的合理性。一旦新的主节点选举完成，哨兵会通知客户端进行切换。

4. **配置提供与更新：** 哨兵节点还负责监控集群配置的变化。当主节点发生故障转移后，哨兵会更新集群配置，将新的主节点信息通知给客户端，以便客户端能够连接到新的主节点。

5. **故障恢复：** 一旦原来的主节点恢复正常，它可以作为新的从节点重新加入集群，并参与复制数据，从而实现故障恢复。

哨兵机制提供了一定程度的高可用性和故障恢复能力，但它仍然是一个异步的过程，可能会有一些延迟。此外，哨兵机制并不能解决所有可能的故障情况，例如多个哨兵同时发生故障时，仍可能导致集群不可用。

为了进一步增强Redis集群的可用性和稳定性，也可以考虑使用Redis Cluster（分布式集群）或者结合其他方案（如复制、备份等）来实现更全面的数据保护和故障恢复策略。

---
Redis的集群模式是一种用于横向扩展和分布式部署的方式，它允许将数据分布在多个节点上，提高了系统的性能和可用性。Redis Cluster是Redis官方提供的集群模式，它支持自动分片、数据复制和故障转移，以实现高性能和高可用性的分布式存储。

以下是Redis Cluster的一些关键特点和工作原理：

1. **分区和分片：** Redis Cluster使用分区（Sharding）来将数据分散在多个节点上。每个节点负责存储部分数据，通过哈希函数将不同的键映射到不同的节点上。

2. **节点拓扑：** Redis Cluster由多个节点组成，每个节点可以是主节点或从节点。每个主节点可以有多个从节点，从节点用于数据复制和故障转移。

3. **数据复制：** Redis Cluster中的主节点会将数据异步复制到其对应的从节点上，从而实现数据的冗余备份和高可用性。从节点可以在主节点故障时被提升为新的主节点，以实现故障转移。

4. **故障转移：** 当主节点发生故障时，Redis Cluster会自动进行故障转移，选择一个从节点升级为新的主节点，并通知客户端更新配置。这样可以在不中断服务的情况下实现故障恢复。

5. **客户端路由：** 客户端与Redis Cluster通信时，需要使用特定的路由算法来确定目标节点，以保证数据的正确访问。客户端通过查询集群的节点拓扑信息来确定数据所在的节点。

6. **Gossip协议：** Redis Cluster使用Gossip协议来进行节点间的信息传播和拓扑管理。节点通过定期互相发送状态信息，以确保集群拓扑的一致性。

7. **主从复制和Failover：** Redis Cluster中的从节点不仅用于数据复制，还可以在主节点故障时承担主节点的角色，实现自动的故障转移。

8. **横向扩展：** 可以随时增加或减少节点来实现横向扩展或缩减集群的容量。

Redis Cluster提供了一种强大的分布式解决方案，适用于需要高性能和高可用性的应用场景。但同时也需要注意，Redis Cluster的配置和管理相对复杂，需要仔细考虑数据分布、故障处理等问题。在设计和使用时，建议查阅Redis官方文档和相关资料，以确保正确地实现和维护集群。

**Redis主从复制：**

答：
Redis的主从复制（Master-Slave Replication）是一种数据复制机制，它允许将一个Redis数据库（主节点）的数据复制到其他一个或多个Redis数据库（从节点）上。主从复制常用于实现数据备份、负载均衡、读写分离和故障转移等需求。

以下是Redis主从复制的基本工作原理：

1. **主节点（Master）：** 主节点是数据复制的源头，它负责处理写操作（SET、UPDATE、DELETE）并将写操作记录到内存数据库（数据集）中。主节点还将写操作记录到一个称为"写操作日志"或"AOF日志"（Append-Only File）的文件中，或者记录到"二进制日志"（RDB文件）中。

2. **从节点（Slave）：** 从节点是数据复制的目标，它连接到主节点并获取主节点的写操作记录。从节点会根据主节点的操作进行数据复制，使自己的数据保持与主节点一致。

3. **全量同步：** 在初始阶段，从节点需要进行全量同步，它向主节点请求所有数据，并将主节点的数据拷贝到自己的内存数据库中。这确保了从节点和主节点的数据一致性。

4. **增量同步：** 一旦全量同步完成，从节点会通过订阅主节点的写操作日志（AOF或者RDB文件）来进行增量同步。从节点会实时地将主节点的写操作应用到自己的内存数据库中，以保持数据的一致性。

5. **读写分离和负载均衡：** 通过配置客户端，你可以实现读写分离，将读操作分发到从节点，从而减轻主节点的负载，提高整体性能。

6. **故障转移：** 如果主节点发生故障，你可以手动将一个从节点提升为新的主节点，以实现故障转移。这种方式可以确保系统的可用性，但需要手动干预。

需要注意的是，Redis的主从复制是一个异步的过程，从节点的数据可能不会立即与主节点保持完全一致。在一些情况下，可能会出现数据延迟或不一致的情况。在设计和使用时，需要根据业务需求来决定是否使用主从复制，以及如何处理延迟和一致性等问题。

**redis的哨兵机制和集群模式有什么区别？**

答：
Redis的哨兵机制（Sentinel）和集群模式（Cluster）都是用于提高Redis的高可用性和可扩展性的解决方案，但它们在实现方式和功能上有一些区别。

**哨兵机制（Sentinel）：**

1. **目的：** 哨兵机制主要用于监控和管理单个Redis实例或主从复制架构，以实现故障转移和高可用性。

2. **部署方式：** 哨兵机制需要在一个独立的哨兵集群中运行，这些哨兵节点会监控并管理一个或多个Redis主节点以及其对应的从节点。

3. **故障转移：** 当主节点发生故障时，哨兵会选举一个从节点升级为新的主节点，然后通知客户端更新配置。故障转移通常需要手动或半自动干预来触发。

4. **主从复制：** 哨兵机制支持主从复制，从节点可以用于数据备份和故障转移。

**集群模式（Cluster）：**

1. **目的：** 集群模式旨在实现分布式数据存储和高可用性，适用于需要横向扩展的场景。

2. **部署方式：** 集群模式需要将数据分散在多个节点上，每个节点负责存储部分数据，具有自动数据分片和复制功能。

3. **数据分布：** 集群模式通过哈希分片将数据分布在多个节点上，节点之间相互协调和通信，实现数据的均衡和高可用性。

4. **故障转移：** 集群模式可以自动进行故障转移，当主节点发生故障时，自动选举新的主节点，并通知客户端更新。

5. **横向扩展：** 集群模式支持横向扩展，可以随时增加或减少节点，以适应负载的变化。

总的来说，哨兵机制主要用于监控和管理主从复制架构，适用于单个实例或少数实例的高可用性需求。而集群模式更适合需要横向扩展和分布式部署的场景，能够实现更高的性能和可用性。选择哪种方案取决于具体的应用需求和架构设计。
